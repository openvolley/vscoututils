## functions for building and working with scout files

#' Expand scouted rally codes
#'
#' * insert dummy rally rows for score corrections. Note that this will not adjust the setter position in the dummy rows nor insert intermediate setter positions (but will insert one setter position code per team at the start of the returned data frame, if needed)
#' * for a substitution, insert the setter assignment code (*PXX or aPXX) if it was the on-court setter that was substituted
#' * insert the setter position codes at the start of the rally. These should not be inserted on the first point of a set, in that situation they should be in the >LUp codes - so for the first point, make sure that the `last_home_setter_position` and `last_visiting_setter_position` are passed as their starting values)
#'
#' @param rx data.frame: with at least the columns:
#' * point_id, code, team ("*" or "a"), point, substitution, timeout, home_setter_position, visiting_setter_position
#' * home_team_score, visiting_team_score (scores at the end of the rally)
#' * player_out, player_in (substitions)
#' and optional columns:
#' * player_number, skill (one-character code), skill_type_code, evaluation_code (used to rebuild the codes before calling [dv_green_codes()]
#' @param last_home_setter_position,last_visiting_setter_position integer: home and visiting setter positions in the previous rally
#' @param last_home_team_score,last_visiting_team_score integer: home and visiting team scores at the end of the previous rally
#' @param keepcols character: names of the columns in `rx` to keep, when inserting new rows. Values in these columns will be copied from an adjacent row. If `keepcols` is not provided, a guess will be made
#' @param meta list: meta component from a datavolley object
#' @param rebuild_codes logical: if `TRUE`, reconstruct the scout code before calling [dv_green_codes()]
#' @param do_warn logical: if `FALSE`, suppress warnings issued directly by this function (but warnings generated by downstream code will still occur)
#'
#' @return `rx` potentially with additional rows inserted. Note that the added rows might have fractional `point_id` values, in which case you will need to renumber all `point_id`s in the match to integers afterwards
#'
#' @export
dv_expand_rally_codes <- function(rx, last_home_setter_position, last_visiting_setter_position, last_home_team_score, last_visiting_team_score, keepcols, meta, rebuild_codes = TRUE, do_warn = TRUE) {
    assert_that(is.data.frame(rx))
    if (nrow(rx) < 1) return(rx)
    req <- c("point_id", "code", "team", "point", "substitution", "timeout", "home_setter_position", "visiting_setter_position", "home_team_score", "visiting_team_score")
    if (!all(req %in% names(rx))) stop("rx is missing required columns: ", paste0(setdiff(req, names(rx)), collapse = ", "))
    opt1 <- c("player_number", "skill", "skill_type_code", "evaluation_code")
    do_warn <- isTRUE(do_warn)
    if (isTRUE(rebuild_codes)) {
        if (any(opt1 %in% names(rx)) && !all(opt1 %in% names(rx))) {
            if (do_warn) warning("rx has some but not all required columns to rebuild the codes to pass to dv_green_codes, so using existing `code` column (missing columns: ", paste0(setdiff(opt1, names(rx)), collapse = ","), ")")
        }
    }
    if (missing(keepcols)) keepcols <- c("point_id", "time", "video_time", "home_team_score", "visiting_team_score", "point_won_by", "set_number",
                                         "home_setter_position", "visiting_setter_position", paste0("home_p", 1:6), paste0("visiting_p", 1:6),
                                         paste0("home_player_id", 1:6), paste0("visiting_player_id", 1:6))
    assert_that(is.character(keepcols))
    keepcols <- intersect(names(rx), keepcols)
    is_sub <- is_to <- is_sc <- is_point <- FALSE
    if (any(rx$substitution)) {
        stopifnot(nrow(rx) == 1)
        is_sub <- TRUE
    } else if (any(rx$timeout)) {
        stopifnot(nrow(rx) == 1)
        is_to <- TRUE
    } else if (nrow(rx) == 1 && isTRUE(rx$point)) {
        ## `point` indicates that the score changed, either through a genuine rally or via a score correction
        ## single row is score correction
        is_sc <- TRUE
    } else if (any(rx$point)) {
        ## otherwise rally with point
        is_point <- TRUE
    }
    ## if this was this a substitution, did the setter get substituted?
    if (is_sub) {
        newcodes <- c()
        if (rx$team %eq% "*") {
            setter_num <- tryCatch(rx[[paste0("home_p", rx$home_setter_position)]], error = NA_integer_)
        } else if (rx$team %eq% "a") {
            setter_num <- tryCatch(rx[[paste0("visiting_p", rx$visiting_setter_position)]], error = NA_integer_)
        }
        if (is.na(setter_num)) {
            if (do_warn) warning("substitution but unknown team or setter number, so not checking if setter was substituted")
        } else {
            ## the lineup should already have changed on this line, so the player coming in should be in the on-court lineup in the setter position
            ## but check the outgoing player as well
            if (setter_num %in% c(rx$player_in, rx$player_out)) {
                ## insert the setter assignment code and the setter location code always follows it
                newcodes <- c(paste0(rx$team, "P", lead0(rx$player_in, na = "00")),
                              paste0(rx$team, "z", if (rx$team %eq% "*") rx$home_setter_position else rx$visiting_setter_position))
            }
        }
        ## add the new codes
        if (length(newcodes) > 0) rx <- bind_rows(rx, rx[rep(1L, length(newcodes)), keepcols] %>% mutate(team = substr(newcodes, 1, 1), point = FALSE, timeout = FALSE, substitution = FALSE, code = newcodes))
    } else if (is_sc) {
        ## score correction, add pc rows if needed, there may need to be more than one
        ## also discard the existing point code, because it will need to be re-created in sequence here
        last_scores <- c(last_home_team_score, last_visiting_team_score)
        hts_delta <- rx$home_team_score - last_scores[1] ## change in home team score
        vts_delta <- rx$visiting_team_score - last_scores[2] ## change in visiting team score
        n_adj <- abs(hts_delta) + abs(vts_delta) ## the number of score adjustments we'll insert
        newcodes <- newscores_h <- newscores_v <- c()
        ## note that we don't try and keep track of setter positions through this and enter the appropriate *z/az codes. Just enter the first one (code block below)
        if (hts_delta != 0) {
            for (sci in (seq_len(abs(hts_delta)) * sign(hts_delta))) {
                thiscodes <- dv_green_codes(paste0("*p", lead0(last_scores[1] + sci), ":", lead0(last_scores[2])), meta, do_warn = do_warn)
                newscores_h <- c(newscores_h, rep(last_scores[1] + sci, length(thiscodes)))
                newcodes <- c(newcodes, thiscodes)
            }
            newscores_v <- rep(last_scores[2], length(newscores_h))
            last_scores[1] <- rx$home_team_score
        }
        if (vts_delta != 0) {
            for (sci in (seq_len(abs(vts_delta)) * sign(vts_delta))) {
                thiscodes <- dv_green_codes(paste0("ap", lead0(last_scores[1]), ":", lead0(last_scores[2] + sci)), meta, do_warn = do_warn)
                newscores_v <- c(newscores_v, rep(last_scores[2] + sci, length(thiscodes)))
                newcodes <- c(newcodes, thiscodes)
                newscores_h <- c(newscores_h, rep(last_scores[1], length(thiscodes)))
            }
        }
        if (length(newcodes) != (n_adj * 3)) stop("adjustment length wrong?")
        ## if a point is being subtracted, it is still given a # green code ("point win") for that team, which seems a bit silly
        temp_point_ids <- rx$point_id
        if (n_adj > 1) temp_point_ids <- temp_point_ids + rep(seq_len(abs(hts_delta) + abs(vts_delta)), each = 3) / (n_adj + 1L)
        rx <- rx[rep(1L, length(newcodes)), keepcols] %>% mutate(team = substr(newcodes, 1, 1), point_id = temp_point_ids, point = substr(newcodes, 2, 2) == "p", code = newcodes, home_team_score = newscores_h, visiting_team_score = newscores_v, substitution = FALSE, timeout = FALSE)
    } else if (is_point) {
        ## add green codes
        if (!all(rx$team %in% c("a", "*"))) {
            stop("not all team values in rx are '*' or 'a'")
        }
        ss1 <- function(x) case_when(!is.na(x) & nzchar(x) ~ substr(x, 1, 1), TRUE ~ "~")
        if (isTRUE(rebuild_codes) && all(opt1 %in% names(rx))) {
            ## reconstruct codes first, codes to dv_green_codes need to be real ones
            temp_codes <- paste0(ss1(rx$team), lead0(rx$player_number, na = "00"), ss1(rx$skill), ss1(rx$skill_type_code), ss1(rx$evaluation_code))
            temp_codes[which(rx$point)] <- rx$code[which(rx$point)] ## retain the original point code
            codes2 <- dv_green_codes(temp_codes, meta, do_warn = do_warn)
        } else {
            codes2 <- dv_green_codes(rx$code, meta, do_warn = do_warn)
        }
        ## the last element of codes2 will be the point code pc, any other extras need to be injected
        if (length(codes2) > nrow(rx)) {
            newcodes <- codes2[seq(from = nrow(rx), to = length(codes2) - 1L, by = 1L)] ## add these codes
            rx <- bind_rows(head(rx, -1), ## not the last row
                            rx[rep(nrow(rx) - 1L, length(newcodes)), keepcols] %>% mutate(team = substr(newcodes, 1, 1), point = FALSE, timeout = FALSE, substitution = FALSE, code = newcodes),
                            tail(rx, 1))
        }
    }
    ## insert setter position codes, when setter has changed position (and not on first point, those come in the >LUp codes - so for the first point, make sure that the last_home_setter_position and last_visiting_setter_position are passed as their starting values)
    spcodes <- if (!rx$home_setter_position[1] %eq% last_home_setter_position) paste0("*z", rx$home_setter_position[1]) else c()
    if (!rx$visiting_setter_position[1] %eq% last_visiting_setter_position) spcodes <- c(spcodes, paste0("az", rx$visiting_setter_position[1]))
    if (length(spcodes) > 0) rx <- bind_rows(rx[rep(1, length(spcodes)), keepcols] %>% mutate(team = substr(spcodes, 1, 1), point = FALSE, code = spcodes), rx)
    rx
}

#' Add green codes to the scouted codes from a rally
#'
#' @param code character: a character vector of scouted codes for a rally. The codes must be non-compound but need only be the first 6 characters (i.e. up to and including the evaluation_code). The code vector must have a valid point code at the end (the `*p` or `ap` code)
#' @param meta list: meta component from a datavolley object
#' @param do_warn logical: if `FALSE`, suppress warnings issued directly by this function (but warnings generated by downstream code will still occur)
#'
#' @return A character vector of codes. This will be the same as the input `code` vector, but potentially with additional green code entries (`$$&H#`, `$$&H=`) inserted before the last entry
#'
#' @export
dv_green_codes <- function(code, meta, do_warn = TRUE) {
    if (all(tolower(substr(code, 2, 2)) %in% c("t", "c"))) return(code) ## timeout or sub
    do_warn <- isTRUE(do_warn)
    if (!grepl("^[a\\*]p[[:digit:]]+:[[:digit:]]+", tail(code, 1))) stop("the final element of the code vector should be the '*p' or 'ap' code")
    won_by <- substr(tail(code, 1), 1, 1)
    if (!won_by %in% c("*", "a")) stop("won_by must be '*' or 'a'")
    team_char <- substr(code, 1, 1)
    team_char[!team_char %in% c("*", "a")] <- NA_character_ ## "*" or "a"
    skill <- substr(code, 4, 4)
    skill[!skill %in% c("S", "R", "A", "B", "D", "E", "F")] <- NA_character_
    evaluation_code <- substr(code, 6, 6)
    evaluation_code[!evaluation_code %in% c("#", "+", "!", "-", "/", "=")] <- NA_character_
    wswin <- meta$winning_symbols$win_lose == "W"
    ## for each skill/eval pair in code, is it a W or L or neither?
    my_wl <- vapply(seq_along(skill), function(i) {
        out <- meta$winning_symbols[meta$winning_symbols$skill %eq% skill[i] & meta$winning_symbols$code %eq% evaluation_code[i], ]
        if (nrow(out) == 1) out$win_lose else NA_character_
    }, FUN.VALUE = "A", USE.NAMES = FALSE)
    wsidx <- my_wl %eq% "W"
    lsidx <- my_wl %eq% "L"
    green_codes <- c()
    lost_by <- setdiff(c("*", "a"), won_by)
    if (sum(team_char %eq% won_by & wsidx) < 1) {
        green_codes <- paste0(won_by, "$$&H#")
    } else if (sum(team_char %eq% lost_by & wsidx) > 0) {
        if (do_warn) warning("winning code for wrong team?")
    }
    if (sum(team_char %eq% lost_by & lsidx) < 1) {
        green_codes <- c(green_codes, paste0(lost_by, "$$&H="))
    } else if (sum(team_char %eq% won_by & lsidx) > 0) {
        if (do_warn) warning("losing code for wrong team?")
    }
    c(head(code, -1), green_codes, tail(code, 1))
}

#' Insert technical timeouts
#'
#' @param x datavolleyplays: the plays component of a datavolley object as returned by `dv_read()`
#' @param at list: (optional) a two-element list can be supplied, giving the scores at which technical timeouts will be inserted for sets 1--4, and set 5 or golden sets. If not provided, technical timeouts are inserted at points 8 and 16 of sets 1--4 (for indoor files) or when the team scores sum to 21 in sets 1--2 (beach)
#' @param data_type string: "indoor" or "beach". If not provided, a guess will be made as to whether `x` is beach or indoor data
#' @return A modified copy of `x`
#'
#' @export
dv_insert_technical_timeouts <- function(x, at, data_type) {
    if (missing(data_type)) data_type <- dv_guess_data_type(x)
    if (!grepl("indoor|beach", data_type)) stop("unrecognized data_type: ", data_type)
    if (missing(at)) {
        at <- if (grepl("beach", data_type)) list(function(s1, s2) (s1 + s2) == 21, NULL) else list(c(8, 16), NULL)
    } else {
        at <- list(NULL, NULL)
    }
    set_sets <- if (grepl("beach", data_type)) list(1:2, 3) else list(1:4, 5)
    keepcols <- intersect(names(x), c("match_id", "time", "video_time", "set_number", "home_team_score", "visiting_team_score", "home_setter_position", "visiting_setter_position", paste0("home_p", 1:6), paste0("visiting_p", 1:6), paste0("home_player_id", 1:6), paste0("visiting_player_id", 1:6), "home_score_start_of_point", "visiting_score_start_of_point"))

    for (si in 1:2) {
        if (!is.null(at[[si]])) {
            if (is.numeric(at[[si]])) {
                ## find technical timeouts at e.g. points 8 and 16 in sets 1-4
                for (this_set in set_sets[[si]]) {
                    for (thisp in at[[si]]) {
                        idx <- which((x$home_score_start_of_point == thisp | x$visiting_score_start_of_point == thisp) & x$set_number == this_set)
                        if (length(idx) > 0) {
                            idx <- idx[1]
                            x <- bind_rows(x[seq_len(idx - 1L), ],
                                           x[idx, keepcols] %>% mutate(skill = "Technical timeout", point_id = x$point_id[idx] - 0.5, timeout = TRUE, point = FALSE, end_of_set = FALSE, substitution = FALSE),
                                           x[setdiff(seq_len(nrow(x)), seq_len(idx - 1L)), ])
                        }
                    }
                }
            } else if (is.function(at[[si]])) {
                ## function that is TRUE when a TTO should occur. Note this only allows one such TTO per set
                for (this_set in set_sets[[si]]) {
                    idx <- which(at[[si]](x$home_score_start_of_point, x$visiting_score_start_of_point) & x$set_number == this_set)
                    if (length(idx) > 0) {
                        idx <- idx[1]
                        x <- bind_rows(x[seq_len(idx - 1L), ],
                                       x[idx, keepcols] %>% mutate(skill = "Technical timeout", point_id = x$point_id[idx] - 0.5, timeout = TRUE, point = FALSE, end_of_set = FALSE, substitution = FALSE),
                                       x[setdiff(seq_len(nrow(x)), seq_len(idx - 1L)), ])
                    }
                }
            }
        }
    }
    x
}
